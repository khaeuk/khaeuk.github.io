---
title: SOLID Principles
date: 2023-12-23 00:00:00 +0800
categories: [Software Design Principles]
tags: [Object Oriented Design, SOLID]
---

[Lecture at Yale](https://youtu.be/TMuno5RZNeE?si=87o0UAIOqk5mRI3v) by "Uncle Bob" Robert C. Martin

## Single Responsibility Principle (SRP)
---
A class should have one and only one reason to change, meaning that <b><ins>a class should have only one job.</ins></b>

```python
# file_manager_srp.py

from pathlib import Path
from zipfile import ZipFile

class FileManager:
    def __init__(self, filename):
        self.path = Path(filename)

    def read(self, encoding="utf-8"):
        return self.path.read_text(encoding)

    def write(self, data, encoding="utf-8"):
        self.path.write_text(data, encoding)

    def compress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="w") as archive:
            archive.write(self.path)

    def decompress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="r") as archive:
            archive.extractall()
```

Here, `FileManager` class has two responsibilities :
1. Manage files : `.read()`, `.write()`.
2. Zip archives : `.compress()`, `.decompress()`.

Thus, it violates the SRP. Here is a version that follows the SRP.

```python
# file_manager_srp.py

from pathlib import Path
from zipfile import ZipFile

class FileManager:
    def __init__(self, filename):
        self.path = Path(filename)

    def read(self, encoding="utf-8"):
        return self.path.read_text(encoding)

    def write(self, data, encoding="utf-8"):
        self.path.write_text(data, encoding)

class ZipFileManager:
    def __init__(self, filename):
        self.path = Path(filename)

    def compress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="w") as archive:
            archive.write(self.path)

    def decompress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="r") as archive:
            archive.extractall()
```

Now there are two smaller classes :
* `FileManager`: Manages files.
* `ZipFilManager`: Compresses/Decompresses files using ZIP format.

> **_NOTE:_**
Separating responsibilities can be subjective.


## Open-closed Principle (OCP)
---
Classes should be <b><ins>open for extension but closed for modification.</ins></b> In doing so, we stop ourselves from modifying existing code and causing potential new bugs.


## Liskov Substitution Principle (LSP)
---
If class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program.


## Interface Segregation Principle (ISP)
Larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.


## Dependency Inversion Principle (DIP)
Decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.


Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.


## References
---
* [SOLID Coding in Python](https://towardsdatascience.com/solid-coding-in-python-1281392a6a94)