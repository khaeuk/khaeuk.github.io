---
title: SOLID Principles
date: 2023-12-23 00:00:00 +0800
categories: [Software Design Principles]
tags: [Object Oriented Design, SOLID, SRP, OCP, LSP, ISP, DIP]
---

[Lecture at Yale](https://youtu.be/TMuno5RZNeE?si=87o0UAIOqk5mRI3v) by "Uncle Bob" Robert C. Martin


## Single Responsibility Principle (SRP)
---
A class should have one and only one reason to change, meaning that <b><ins>a class should have only one job.</ins></b>

```python
# file_manager_srp.py

from pathlib import Path
from zipfile import ZipFile

class FileManager:
    def __init__(self, filename):
        self.path = Path(filename)

    def read(self, encoding="utf-8"):
        return self.path.read_text(encoding)

    def write(self, data, encoding="utf-8"):
        self.path.write_text(data, encoding)

    def compress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="w") as archive:
            archive.write(self.path)

    def decompress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="r") as archive:
            archive.extractall()
```

Here, `FileManager` class has two responsibilities :
1. Manage files : `.read()`, `.write()`.
2. Zip archives : `.compress()`, `.decompress()`.

Thus, it violates the SRP. Here is a version that follows the SRP.

```python
# file_manager_srp.py

from pathlib import Path
from zipfile import ZipFile

class FileManager:
    def __init__(self, filename):
        self.path = Path(filename)

    def read(self, encoding="utf-8"):
        return self.path.read_text(encoding)

    def write(self, data, encoding="utf-8"):
        self.path.write_text(data, encoding)

class ZipFileManager:
    def __init__(self, filename):
        self.path = Path(filename)

    def compress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="w") as archive:
            archive.write(self.path)

    def decompress(self):
        with ZipFile(self.path.with_suffix(".zip"), mode="r") as archive:
            archive.extractall()
```

Now there are two smaller classes :
* `FileManager`: Manages files.
* `ZipFilManager`: Compresses/Decompresses files using ZIP format.

> **_NOTE:_**
Separating responsibilities can be subjective.


## Open-closed Principle (OCP)
---
Classes should be <b><ins>open for extension but closed for modification.</ins></b> In doing so, we stop ourselves from modifying existing code and causing potential new bugs.

Let's start with the following code:
```python
# shapes_ocp.py

from math import pi

class Shape:
    def __init__(self, shape_type, **kwargs):
        self.shape_type = shape_type
        if self.shape_type == "rectangle":
            self.width = kwargs["width"]
            self.height = kwargs["height"]
        elif self.shape_type == "circle":
            self.radius = kwargs["radius"]

    def calculate_area(self):
        if self.shape_type == "rectangle":
            return self.width * self.height
        elif self.shape_type == "circle":
            return pi * self.radius**2
```

This code utilizes a lot of `if/elif/else` statements to instantiate the object and to calculate the area of the shape.

```python
>>> from shapes_ocp import Shape

>>> rectangle = Shape("rectangle", width=10, height=5)
>>> rectangle.calculate_area()
50
>>> circle = Shape("circle", radius=5)
>>> circle.calculate_area()
78.53981633974483
```

> #### What if you want to add a square?
> The easiest way is to add another `elif` statement for "square" in both `__init__()` and `calculate_area()`.

The answer to the above question makes the class `Shape` open for modification, which violates OCP.

#### How do you properly fix it to comply with OCP?
```python
# shapes_ocp.py

from abc import ABC, abstractmethod
from math import pi

class Shape(ABC):
    def __init__(self, shape_type):
        self.shape_type = shape_type

    @abstractmethod
    def calculate_area(self):
        pass

class Circle(Shape):
    def __init__(self, radius):
        super().__init__("circle")
        self.radius = radius

    def calculate_area(self):
        return pi * self.radius**2

class Rectangle(Shape):
    def __init__(self, width, height):
        super().__init__("rectangle")
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height

class Square(Shape):
    def __init__(self, side):
        super().__init__("square")
        self.side = side

    def calculate_area(self):
        return self.side**2
```

The `Shape` class is set as ***Abstract Base Class (ABC)*** and sets the interface for all shapes (aka, it's ***polymorphic***). The `Shape` class is now free from modification whenever a new shape needs to be added.


## Liskov Substitution Principle (LSP)
---
If class A is a subtype of class B, we should be able to replace B with A without disrupting the behavior of our program.
> Subtypes must be substitutable for their base types.

Take this Rectangle class for example.
```python
# shapes_lsp.py

class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def calculate_area(self):
        return self.width * self.height        
```




## Interface Segregation Principle (ISP)
Larger interfaces should be split into smaller ones. By doing so, we can ensure that implementing classes only need to be concerned about the methods that are of interest to them.


## Dependency Inversion Principle (DIP)
Decoupling of software modules. This way, instead of high-level modules depending on low-level modules, both will depend on abstractions.


Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.


## References
---
* [SOLID Coding in Python](https://towardsdatascience.com/solid-coding-in-python-1281392a6a94)